<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Includes all JS & CSS for the JavaScript Data Grid -->
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.js"></script>
</head>

<body>
    <h1>Calculate your class grade</h1>
    <p>Click on a percentage cell to change the value to one that fits your results.</p>
    <em>Warning: Values you enter are stored in the browser for your convenience.
        On public computers, you can reset stored data by pressing this button.
        <button onclick="resetData()">Reset data</button>
    </em>
    <div id="myGrid" class="ag-theme-quartz"></div>
    <p>
        <script>
            // Created by Lee McPherson, May 2024 (lee.mcpherson@pcc.edu, leemcpherson@hotmail.com)

            // Column Definitions: Defines the columns to be displayed.

            let parentGrid = null;

            const columnDefsWeighted = [
                {
                    field: "name",
                    cellRenderer: p => {
                        const div = document.createElement('div');
                        div.style = "display: inline-flex;align-items: center;";

                        const title = document.createElement('span');

                        if (p.data.gradeItems && p.data.gradeItems.length > 0) {
                            //if (p.data.gradeItems.length > 1) {

                            const button = document.createElement('button');
                            button.classList.add('ag-button');
                            button.classList.add('ag-floating-filter-button-button');
                            button.style = "display:flex;";
                            const innerspan = document.createElement('span');
                            innerspan.classList.add('ag-icon');
                            innerspan.classList.add('ag-icon-tree-closed');
                            button.appendChild(innerspan);
                            //button.innerHTML = "&#xf130";
                            button.onclick = x => {
                                p.data.isExpanded = !p.data.isExpanded;
                                p.api.resetRowHeights();
                                p.api.redrawRows({ rowNodes: [p.node] });
                            };
                            div.appendChild(button);

                            title.innerHTML = 'Category: ' + p.data.name + ' (' + p.data.gradeItems.length + ')';
                        } else {
                            title.innerHTML = p.data.name;
                        }
                        div.appendChild(title);
                        return div;
                    }

                },
                {
                    field: "value",
                    editable: true,
                    singleClickEdit: true,
                    cellStyle: p => {
                        if (p.data.name === 'Class Grade') {
                            return { display: 'none' };
                        }
                        return { border: '2px black solid' }
                    },
                    onCellValueChanged: (e) => {
                        // Write to browser first.
                        try {
                            let data = {};
                            e.api.forEachNode(node => {
                                data[node.data.category] = node.data.value;
                            });
                            localStorage.setItem(savedDataName, JSON.stringify(data));
                        } catch { }
                        // Calculate aggregation row
                        generatePinnedBottomData(e.api);
                    }
                },
                {
                    // remove this field if category & isWeighted
                    field: "maxValue",
                    cellStyle: p => {
                        if (p.data.category === 'Class Grade') {
                            return { display: 'none' };
                        }
                        return;
                    },
                },
                {
                    field: "weight",
                    cellStyle: p => {
                        if (p.data.category === 'Class Grade') {
                            return { display: 'none' };
                        }
                        return;
                    },
                },
                {
                    field: "weightedValue",
                    valueGetter: p => {
                        if (p.data.category === 'Class Grade') {
                            return p.data.points;
                        }
                        return p.data.percentageScore / 100 * p.data.weight;
                    },
                    valueFormatter: p => {
                        if (p.data.category === 'Class Grade') {
                            return p.value.toFixed(1) + '%';
                        } else {
                            return (p.value) ? p.value.toFixed(1) : '1';
                        }
                    }
                }
            ];

            const columnDefsPoints = [
                {
                    field: "name",
                    cellRenderer: p => {
                        const div = document.createElement('div');
                        div.style = "display: inline-flex;align-items: center;";

                        const title = document.createElement('span');

                        if (p.data.gradeItems && p.data.gradeItems.length > 0) {
                            //if (p.data.gradeItems.length > 1) {

                            const button = document.createElement('button');
                            button.classList.add('ag-button');
                            button.classList.add('ag-floating-filter-button-button');
                            button.style = "display:flex;";
                            const innerspan = document.createElement('span');
                            innerspan.classList.add('ag-icon');
                            innerspan.classList.add('ag-icon-tree-closed');
                            button.appendChild(innerspan);
                            //button.innerHTML = "&#xf130";
                            button.onclick = x => {
                                p.data.isExpanded = !p.data.isExpanded;
                                p.api.resetRowHeights();
                                p.api.redrawRows({ rowNodes: [p.node] });
                                generatePinnedBottomData(parentGrid);
                            };
                            div.appendChild(button);

                            title.innerHTML = 'Category: ' + p.data.name + ' (' + p.data.gradeItems.length + ')';
                        } else {
                            title.innerHTML = p.data.name;
                        }
                        div.appendChild(title);
                        return div;
                    }

                },
                {
                    field: "value",
                    editable: p => p.data.name !== 'Class Grade',
                    singleClickEdit: true,
                    cellStyle: p => {
                        if (p.data.name === 'Class Grade') {
                            return {};
                        }
                        return { border: '2px black solid' }
                    },
                    onCellValueChanged: (e) => {
                        // check if cell is inside a category... if so, change category total/percentage
                        console.log(e);
                        if (e.data.parent != null){
                            let parent = e.data.parent;
                            let total = 0;
                            for (const item of parent.rowData){
                                total += item.value;
                            }
                            parent.value = total;
                            generatePinnedBottomData(parentGrid);
                        } else {
                            // Calculate aggregation row
                            generatePinnedBottomData(e.api);
                        }
                        // // Write to browser first.
                        // try {
                        //     let data = {};
                        //     e.api.forEachNode(node => {
                        //         data[node.data.category] = node.data.value;
                        //     });
                        //     localStorage.setItem(savedDataName, JSON.stringify(data));
                        // } catch { }
                        
                    }
                },
                {
                    // remove this field if category & isWeighted
                    field: "maxValue"
                },
                {
                    field: "percentage",
                    valueGetter: p => {
                        if (p.data.category === 'Class Grade') {
                            return p.data.points;
                        }
                        return p.data.value / p.data.maxValue * 100;
                    },
                    valueFormatter: p => {
                        return p.value.toFixed(1) + '%';
                    }
                }
            ];


            async function getAPIDataAsync() {

                // D2L specific:  try and get token then download grades from API
                let tokenData = await window.localStorage.getItem('D2L.Fetch.Tokens');
                if (tokenData) {
                    tokenData = JSON.parse(tokenData);
                    const token = tokenData["*:*:*"]["access_token"];
                    console.log(token);

                    // get org unit
                    const hrefsplit = window.parent.location.href.split('/');
                    const orgUnitId = hrefsplit[hrefsplit.indexOf('content') + 1];
                    console.log(orgUnitId);

                    const fetchOptions = {
                        method: 'GET',
                        withCredentials: true,
                        credentials: 'include',
                        headers: {
                            'Authorization': 'Bearer ' + token,
                            'Content-Type': 'application/json'
                        }
                    };

                    const responseSetup = await fetch(window.location.origin + "/d2l/api/le/1.67/" + orgUnitId + "/grades/setup/");
                    const setup = await responseSetup.json();
                    const isWeighted = setup.GradingSystem === "Weighted";
                    const isPoints = setup.GradingSystem === "Points";

                    const responseScheme = await fetch(window.location.origin + "/d2l/api/le/1.67/" + orgUnitId + "/grades/schemes/");
                    const scheme = await responseScheme.json();
                    console.log(scheme);

                    const responseGradeObjects = await fetch(window.location.origin + "/d2l/api/le/1.67/" + orgUnitId + "/grades/");
                    const gradeObjects = await responseGradeObjects.json();
                    console.log(gradeObjects);

                    const responseCategories = await fetch(window.location.origin + "/d2l/api/le/1.67/" + orgUnitId + "/grades/categories/", fetchOptions);
                    const categories = await responseCategories.json();
                    console.log(categories);

                    const responseMyGrades = await fetch(window.location.origin + "/d2l/api/le/1.67/" + orgUnitId + "/grades/values/myGradeValues/", fetchOptions);
                    const myGrades = await responseMyGrades.json();
                    console.log(myGrades);

                    // check browser for stored data from last page access
                    let pageName = location.href.replaceAll('/', '').replaceAll(':', '');
                    const savedDataName = 'gradeData' + pageName;
                    let savedData;
                    try {
                        savedData = window.localStorage.getItem(savedDataName);
                        if (savedData) {
                            savedData = JSON.parse(savedData);
                            // should be json object: category=>value
                        }
                    } catch {

                    }


                    // Edit default percentage score for categories here.
                    const defaultPercentage = 100;

                    let rowData = gradeObjects.filter(v => v.CategoryId == 0 && v.Weight != 0 && v.GradeType == 'Numeric').map(v => {
                        let value = v.MaxPoints;
                        let grade = myGrades.find(x => x.GradeObjectIdentifier == v.Id);
                        if (grade) {
                            value = grade.PointsNumerator;
                        }
                        return { name: v.Name, weight: v.Weight, rowData: null, gradeItems: [], maxValue: v.MaxPoints, value: value, isExpanded: false, parent: null };
                    });
                    let rowDataCategories = categories.filter(v => v.Grades && v.Grades.filter(x => x.GradeType == 'Numeric').length > 0).map((v, i, a) => {
                        let result = { name: v.Name, weight: v.Weight, rowData: null, gradeItems: v.Grades, maxValue: v.MaxPoints, value: v.MaxPoints, isExpanded: false, parent: null };
                        //let value = v.MaxPoints;
                        let grade = myGrades.find(x => x.GradeObjectIdentifier == v.Id);
                        if (grade) {
                            result.value = v.PointsNumerator;
                        }
                        // get items inside category and pre-format them
                        let subRowData = v.Grades.filter(v2 => v2.GradeType == "Numeric").map((v2, i2, a2) => {
                            let value = v2.MaxPoints;
                            let grade = myGrades.find(x => x.GradeObjectIdentifier == v2.Id);
                            if (grade) {
                                value = grade.PointsNumerator;
                                //value = grade.PointsNumerator / grade.PointsDenominator * 100;
                            }
                            return { name: v2.Name, weight: v2.Weight, gradeItems: [], maxValue: v2.MaxPoints, value: value, isExpanded: false, parent: result };
                        });
                        subRowData = subRowData.filter(x => x.weight != 0); // filter out anything that has no weight (will work for points)
                        result.rowData = subRowData;
                        return result;
                    });
                    rowData = rowData.concat(rowDataCategories);


                    function createGridOptions(rowData) {
                        // Grid Options: Contains all of the data grid configurations
                        const gridOptions = {
                            domLayout: 'autoHeight',
                            stopEditingWhenCellsLoseFocus: true,
                            getRowHeight: p => {
                                if (p.node.rowPinned && p.node.rowPinned === "bottom") {
                                    return 70;
                                }
                                if (p.data.isExpanded) {  //title + header + cells + final border
                                    return 39 + 48 + (p.data.gradeItems.filter(v => v.GradeType == "Numeric").length * 42) + 30;
                                }
                            },
                            getRowStyle: p => {
                                if (p.node.rowPinned && p.node.rowPinned === "bottom") {
                                    return { fontSize: 'x-large', background: '#F4F4F4', paddingTop: '10px' };
                                }
                            },
                            isFullWidthRow: p => {
                                return p.rowNode.data.isExpanded;
                            },
                            fullWidthCellRenderer: fullWidthCellRenderer,
                            // Row Data: The data to be displayed.
                            rowData: rowData,
                            // rowData: rowDataEditable.map(x => {

                            //     if (savedData && savedData[x.category]) {
                            //         x.percentageScore = savedData[x.category];
                            //     } else {
                            //         if (!x.percentageScore) {
                            //             x.percentageScore = defaultPercentage;
                            //         }
                            //     }
                            //     return x;
                            // }),

                            columnDefs: isWeighted ? columnDefsWeighted : columnDefsPoints
                        };
                        return gridOptions;
                    }

                    function fullWidthCellRenderer(p) {
                        //create new grid inside with sub data
                        const div = document.createElement('div');
                        const titleDiv = document.createElement('div');
                        titleDiv.style = "display: inline-flex;align-items: center;";
                        div.appendChild(titleDiv);

                        const button = document.createElement('button');
                        button.classList.add('ag-button');
                        button.classList.add('ag-floating-filter-button-button');
                        button.style = "display:flex;margin-left:10px;";
                        const innerspan = document.createElement('span');
                        innerspan.classList.add('ag-icon');
                        innerspan.classList.add('ag-icon-tree-open');
                        button.appendChild(innerspan);
                        //button.innerHTML = "&#xf130";
                        button.onclick = x => {
                            p.data.isExpanded = !p.data.isExpanded;
                            p.api.resetRowHeights();
                            p.api.redrawRows({ rowNodes: [p.node] });
                            generatePinnedBottomData(parentGrid);
                        };
                        titleDiv.appendChild(button);

                        const title = document.createElement('span');
                        //title.classList.add('ag-cell');
                        title.style = "margin: 10px;";
                        title.innerHTML = "Category: " + p.data.name + "";
                        titleDiv.appendChild(title);

                        const subGridDiv = document.createElement('div');
                        subGridDiv.style = 'margin-left: 30px';
                        subGridDiv.classList.add('ag-theme-quartz');
                        div.appendChild(subGridDiv);
                        const subgrid = agGrid.createGrid(subGridDiv, createGridOptions(p.data.rowData));

                        return div;
                    }

                    // Your Javascript code to create the data grid
                    const myGridElement = document.querySelector('#myGrid');
                    parentGrid = agGrid.createGrid(myGridElement, createGridOptions(rowData));
                    console.log(parentGrid);

                    generatePinnedBottomData(parentGrid);
                    //grid.setGridOption('rowData', newData);
                }
            }




            // Function that calculates the point scores for each row, then aggregates them
            function calculatePinnedBottomData(grid, target) {
                grid.forEachNodeAfterFilter((rowNode) => {
                    if (rowNode.data.value) {
                        if (rowNode.data.isExpanded) {
                            for (const row of rowNode.data.rowData){
                                target.value += row.value;
                                target.maxValue += row.maxValue;
                            }
                        } else {
                            target.value += rowNode.data.value;
                            target.maxValue += rowNode.data.maxValue;
                        }
                    }
                });

                return target;
            };

            // Function that creates the last pinned row that displays aggregate results
            function generatePinnedBottomData(grid) {
                // generate a row-data with null values
                let result = { name: 'Class Grade' };
                result['value'] = 0;
                result['maxValue'] = 0;
                const t = calculatePinnedBottomData(grid, result);
                //t['name'] = 'Class Grade';
                grid.setGridOption('pinnedBottomRowData', [t]);
            }

            function resetData() {
                try {
                    localStorage.clear();
                } catch {

                }
                location.reload();
            }

            // start it all!
            getAPIDataAsync();

        </script>
    </p>
</body>

</html>